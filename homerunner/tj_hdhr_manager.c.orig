#include "tj_hdhr_manager.h"

#define MAX_DEVICES 256

struct _TJHDHRManagerPrivate {
	GHashTable* devices;
	gint discovery_count;
	struct hdhomerun_discover_device_t discoveries;
};

G_DEFINE_TYPE_WITH_PRIVATE (TJHDHRManager, tj_hdhr_manager, GTK_TYPE_GOBJECT);

static gchar*
ipbits_to_str (uint32_t binary_address)
{
	gchar* string = g_malloc (16);
	guchar octet[4];
	gint i;

	for (i = 0; i < 4; i ++) {
		octet[i] = (guchar) (binary_address >> (i*8)) & 0xFF;
	}
	g_snprintf (string, "%u.%u.%u.%u\0", 5, octet[3], octet[2], octet[1], octet[0]);
	g_debug ("IP address is: %s", string);
	return string;
}

static void
tj_hdhr_manager_init_devices (TJHDHRManager* self)
{
	gint i;
	gint count;

	g_free (self->priv->discoveries);
	self->priv->discoveries = g_new0 (struct hdhomerun_discover_device_t, MAX_DEVICES);
	self->priv->discovery_count =  hdhomerun_discover_find_devices_custom (0, HDHOMERUN_DEVICE_TYPE_TUNER, HDHOMERUN_DEVICE_ID_WILDCARD, self->priv->discoveries, MAX_DEVICES);
	if (self->priv->discovery_count == -1) {
		g_debug ("Device discovery failed.");
	}
}

GtkListStore*
tj_hdhr_get_devices (TJHDHRManager* self)
{
	GtkListStore* device_store;
	GtkTreeIter* device_iter;
	guint i;
	gchar* ip_addr_str;

	device_store = gtk_list_store_new (4, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UCHAR);
	if (self->priv->discoveries == NULL) {
		return device_store;
	}
	for (i = 0; i < self->priv->discovery_count; i ++) {
		ip_addr_str = ipbits_to_str (self->priv->discoveries[i].ip_addr);
		g_debug ("Discovered device with at address %s with id %X. It has %u tuners",
				 ip_addr_str,
				 self->priv->discoveries[i].device_id,
				 self->priv->discoveries[i].tuner_count);
		g_free (ip_addr_str);
		gtk_list_store_insert_with_values (device_store,
										   device_iter,
										   -1,
										   self->priv->discoveries[i].device_id,
										   self->priv->discoveries[i].device_type,
										   self->priv->discoveries[i].ip_addr,
										   self->priv->discoveries[i].tuner_count);
	}
	return device_store;
}


void
tj_hdhr_manager_scan_channels (TJHDHRManager* self, GString* path)
{
	struct hdhomerun_discover_device_t* dis;
	struct hdhomerun_device_t* dev;
	guint i;
	guint j;
    char* channelmap;
    const char* channelmap_scan_group;

	for (i = 0; i < self->priv->discovery_count; i ++) {
		dis = self->priv->discoveries[i];
		for (j = 0; j < dis.tuner_count; j ++) {
			dev = hdhomerun_device_create (dis->device_id, dis->ip_addr, j, NULL);
		    if (hdhomerun_device_get_tuner_channelmap (dev, &channelmap) <= 0) {
		        g_debug ("Failed to query channelmap from device\n");
		    }

		    channelmap_scan_group = hdhomerun_channelmap_get_channelmap_scan_group (channelmap);
		    if (! channelmap_scan_group) {
		        g_debug ("Unknown channelmap '%s'\n", channelmap);
		    }

		    if (hdhomerun_device_channelscan_init (hd, channelmap_scan_group) <= 0) {
		        g_debug ("Failed to initialize channel scan\n");
		    }

		    //FILE *fp = NULL;
		    //if (filename)
		    //{
		    //    fp = fopen(filename, "w");
		    //    if (!fp)
		    //    {
		    //        fprintf(stderr, "unable to create file: %s\n", filename);
		    //        return -1;
		    //    }
		    //}

		    int ret;
		    while (1)
		    {
		        struct hdhomerun_channelscan_result_t result;
		        ret = hdhomerun_device_channelscan_advance(hd, &result);
		        if (ret <= 0)
		        {
		            break;
		        }

		        cmd_scan_printf(fp, "SCANNING: %lu (%s)\n", result.frequency,
		                result.channel_str);

		        ret = hdhomerun_device_channelscan_detect(hd, &result);
		        if (ret <= 0)
		        {
		            break;
		        }

		        cmd_scan_printf(fp, "LOCK: %s (ss=%u snq=%u seq=%u)\n",
		                result.status.lock_str, result.status.signal_strength,
		                result.status.signal_to_noise_quality,
		                result.status.symbol_error_quality);

		        int i;
		        for (i = 0; i < result.program_count; i++)
		        {
		            struct hdhomerun_channelscan_program_t *program =
		                    &result.programs[i];
		            cmd_scan_printf(fp, "PROGRAM %s\n", program->program_str);
		        }
		    }

		    if (fp)
		    {
		        fclose(fp);
		    }
		    if (ret < 0)
		    {
		        fprintf(stderr,
		                "communication error sending request to hdhomerun device\n");
		    }
		    return ret;
		}
	}
}

static void
tj_hdhr_manager_class_init (TJHDHRManagerClass* k)
{
}

static void
tj_hdhr_manager_init (TJHDHRManager* self)
{
	self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self, TJ_TYPE_HDHR_MANAGER, TJHDHRManagerPrivate);
	self->priv->devices = NULL;
	self->priv->discovery_count = -1;
}

GObject*
tj_hdhr_manager_new ()
{
	return g_object_new (TJ_TYPE_HDHR_MANAGER, NULL);
}


static void
tj_hdhr_manager_dispose (GObject* object)
{
  TJHDHRManager *self = TJ_HDHR_MANAGER (object);

  /* In dispose(), you are supposed to free all types referenced from this
   * object which might themselves hold a reference to self. Generally,
   * the most simple solution is to unref all members on which you own a
   * reference.
   */

  /* dispose() might be called multiple times, so we must guard against
   * calling g_object_unref() on an invalid GObject by setting the member
   * NULL; g_clear_object() does this for us, atomically.
   */
  //g_clear_object (&self->priv->an_object);

  /* Always chain up to the parent class; there is no need to check if
   * the parent class implements the dispose() virtual function: it is
   * always guaranteed to do so
   */
  G_OBJECT_CLASS (tj_hdhr_manager_parent_class)->dispose (sobject);
}

static void
tj_hdhr_manager_finalize (GObject *object)
{
  TJHDHRManager *self = TJ_HDHR_MANAGER (object);

  g_hash_table_destroy (self->priv->devices);
  g_free (self->priv->discoveries);

  /* Always chain up to the parent class; as with dispose(), finalize()
   * is guaranteed to exist on the parent's class virtual function table
   */
  G_OBJECT_CLASS (tj_hdhr_manager_parent_class)->finalize (gobject);
}
